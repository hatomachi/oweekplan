# Obsidian Weekplan Plugin: Architecture & Philosophy Handover

## 1. プロジェクトの目的とコンテキスト
本プロジェクトは、Obsidian上で動作する「7つの習慣」に準拠した週間タイムブロッキング・プラグインの開発である。
単なる予定管理ではなく、**AI（Gemini等）と協働し、自分にとっての「大きな石（第2領域）」を確実に配置するための作戦会議システム**として機能する。

**【ユーザーの前提コンテキスト（システム要件に直結）】**
* ソフトウェア開発のマネージャー職であり、日中は第1・第3領域の突発的な割り込みが頻発する。
* 健康の回復・維持を最優先とする必要がある。
* したがって、**「1日の稼働の60%（最大6.5時間程度）しかタスクを詰め込まない」「意図的な空白（バッファ）を死守する」**ことが、本システムにおける最も重要な制約事項（ルール）である。

## 2. システム・アーキテクチャ
* **フロントエンド (Obsidian Plugin):** TypeScript, Obsidian API, FullCalendar (with interactionPlugin)
* **バックエンド (ローカルスクリプト):** Python (`win32com.client`)
* **データ構造:** `.weekplan` 拡張子のカスタムYAMLファイル（Single Source of Truth）

**【データフロー】**
1. プラグイン上のボタンを押すと、`child_process` 経由でローカルの `fetch_outlook.py` が走り、クラシックOutlookから直近の予定をJSONで取得。
2. 取得した予定を `.weekplan` ファイルの `events` リスト（type: outlook）として上書き保存。
3. AIが `goals` (タスクプール) をパースし、空き時間を見つけて `events` (type: task) に書き込む。
4. ユーザーがObsidian上のFullCalendarでタスクをドラッグ＆ドロップし、最終的な予実を微調整する。

## 3. UI/UXの設計思想と実装の歴史
開発過程で「AIへの過度な依存」や「使いにくさ」を排除するため、以下のUI要件が実装されている。

* **2ペイン構成:** 左に「AIの考え方(Insight)とタスクツリー」、右に「カレンダー」を配置。
* **タスクのステータス管理:** 左ペインのタスクはYAMLの `status` と連動する。
  * `scheduled` (🟢): カレンダー配置済み。ホバーするとカレンダー上のブロックがハイライトされる。
  * `pool` (🟡): 未配置（プロット漏れ警告）。これを右側のカレンダーにドラッグ＆ドロップすると、自動的に `scheduled` になりYAMLが更新される。
  * `dropped` (⚪): 今週はやらないと決断（見送り）したタスク。
* **予実管理の直感性:** カレンダー上のタスクをクリックすると `pool` に差し戻される。カレンダー上で時間を伸縮させると、即座にYAMLの `start/end` が更新される。
* **脱・完全AI依存:** ソースモード（YAML直接編集）への切替機能や、Obsidian純正モーダル（`Modal` API）を利用した手動での「＋タスク追加」機能を実装済み（Electronの `prompt()` 制限を回避）。

## 4. データ仕様の重要ルール（AIが守るべき制約）
AIが `.weekplan` ファイルを生成・更新する際は、以下のルールを厳守すること。
1. **Insightファースト:** YAMLの先頭 `insight:` に、スケジューリングの戦略やバッファ時間の確保理由を思考プロセス（Chain of Thought）として言語化すること。
2. **役割の分離:** 純粋な目標だけでなく、「組織人（Admin）」としての細々としたタスクも `goals` に含めるが、小さな砂（15分〜30分程度）はカレンダーに配置せず `status: pool` のまま残すこと。
3. **時系列ソートの強制:** AIのハルシネーション（予定の重複）を防ぐため、`events` リストは**必ず `start` (開始日時) の昇順にソートして出力・保存**すること。

## 5. 今後の改善フェーズ（Next Steps）
このファイルを受け取ったAIは、上記の設計思想を完全に理解した上で、今後の機能拡張やコードのリファクタリング、プロンプトの改善をサポートすること。