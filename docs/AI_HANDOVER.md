# Obsidian Weekplan Plugin: Architecture & Philosophy Handover

## 1. プロジェクトの目的とコンテキスト
本プロジェクトは、Obsidian上で動作する「7つの習慣」に準拠した週間タイムブロッキング・プラグインの開発である。
単なる予定管理ではなく、**AI（Gemini等）と協働し、自分にとっての「大きな石（第2領域）」を確実に配置するための作戦会議システム**として機能する。

**【ユーザーの前提コンテキスト（システム要件に直結）】**
* ソフトウェア開発のマネージャー職であり、日中は第1・第3領域の突発的な割り込みが頻発する。
* 健康の回復・維持を最優先とする必要がある。
* したがって、**「1日の稼働の60%（最大6.5時間程度）しかタスクを詰め込まない」「意図的な空白（バッファ）を死守する」**ことが、本システムにおける最も重要な制約事項（ルール）である。

## 2. システム・アーキテクチャ
* **フロントエンド (Obsidian Plugin):** TypeScript, Obsidian API, FullCalendar (with interactionPlugin)
* **バックエンド (ローカルスクリプト):** Python (`win32com.client`)
* **データ構造:** `.weekplan` 拡張子のカスタムYAMLファイル（Single Source of Truth）

**【データフロー】**
1. プラグイン上のボタンを押すと、`child_process` 経由でローカルの `fetch_outlook.py` が走り、クラシックOutlookから直近の予定をJSONで取得。
2. 取得した予定を `.weekplan` ファイルの `events` リスト（type: outlook）として上書き保存。
3. AIが `goals` (タスクプール) をパースし、空き時間を見つけて `events` (type: task) に書き込む。
4. ユーザーがObsidian上のFullCalendarでタスクをドラッグ＆ドロップし、最終的な予実を微調整する。

## 3. UI/UXの設計思想と実装の歴史
開発過程で「AIへの過度な依存」や「使いにくさ」を排除するため、以下のUI要件が実装されている。

* **2ペイン構成:** 左に「AIの考え方(Insight)とタスクツリー」、右に「カレンダー」を配置。
* **タスクのステータス管理:** 左ペインのタスクはカレンダー上の該当枠の合計時間に基づいて自動計算されるほか、手動でのトグルも可能。
  * `scheduled` (🟢): 見積もり時間分がすべてカレンダー配置済み。
  * `partial` (🌓): 一部の時間だけカレンダー配置済み。残りの時間を再度カレンダーにドラッグ可能。
  * `pool` (🟡): 未配置（プロット漏れ警告）。右側のカレンダーにドラッグ＆ドロップすると配置される。
  * `completed` (☑️): 手動完了。文字が薄くなり打ち消し線が入る。カレンダー上の枠は残る。
  * `dropped` (ー): 今週はやらないと手動で決断（見送り）。文字が薄くなる（打ち消し線なし）。
  * 💡 左端のアイコンをクリックすることで、手動ステータス(`completed`, `dropped`) と 自動ステータス(`pool`, `partial`, `scheduled`) をループで切り替え可能。
* **ブロック分割と予実管理の直感性:**
  * カレンダー上のタスク枠を伸縮させると即座にYAMLが更新され、左側の合計時間やステータス（`scheduled` ⇔ `partial` ⇔ `pool`）が再計算される。
  * 1つの目標（タスク）を複数日・複数枠に分割配置可能。（カレンダー上のイベントIDは `タスクID_タイムスタンプ` のように一意に自動生成され、内部的に `taskId` プロパティで左側の目標と紐付く）
  * カレンダー上の枠をクリックすると、その1枠だけを個別に削除可能。
* **脱・完全AI依存:** ソースモード（YAML直接編集）への切替機能や、Obsidian純正モーダル（`Modal` API）を利用した手動での「＋タスク追加」機能を実装済み（Electronの `prompt()` 制限を回避）。

## 4. データ仕様の重要ルール（AIが守るべき制約）
AIが `.weekplan` ファイルを生成・更新する際は、以下のルールを厳守すること。
1. **Insightファースト:** YAMLの先頭 `insight:` に、スケジューリングの戦略やバッファ時間の確保理由を思考プロセス（Chain of Thought）として言語化すること。
2. **役割の分離:** 純粋な目標だけでなく、「組織人（Admin）」としての細々としたタスクも `goals` に含めるが、小さな砂（15分〜30分程度）はカレンダーに配置せず `status: pool` のまま残すこと。
3. **イベントのID構成:** AIが `events` に新規でタスク枠を書き込む際、元のタスクIDをそのまま使用してもよい（プラグイン側で読み込み時によしなに紐付けるため）。1つのタスクを複数回配置する場合は、`taskId: 元のタスクID` を指定し、`id` は `タスクID_1` のように一意にすること。
4. **時系列ソートの強制:** AIのハルシネーション（予定の重複）を防ぐため、`events` リストは**必ず `start` (開始日時) の昇順にソートして出力・保存**すること。
5. **ステータスの正確性:** `goals` 内の各タスクの `status` は、配置したイベント枠の時間合計に基づいて正確に出力すること（全配置=`scheduled`、一部配置=`partial`、未配置=`pool`）。

## 5. AIへの最適な依頼方法（プロンプト・テンプレート）
ユーザーがAI（Gemini/Claude等）にタスクの割り当てを依頼する際、確実性を高めるための推奨プロンプトです。AIにMarkdown表と一緒に以下の指示を渡してください。

```text
あなたは私の優秀な秘書として、提供された「今週の目標（Markdown表）」と「現在のカレンダー空き状況（Outlook予定抽出済みのYAMLの一部）」を見て、最も効果的なスケジュールを `.weekplan` (YAML形式) で提案してください。

以下の【厳守事項】に従ってください：
1. 稼働の60%（1日最大6.5時間）の制約を守り、意図的なバッファ（空白）を残すこと。
2. 見積もり時間が大きい（重い）「第2領域の石」から優先してカレンダー（events）の空き時間に配置すること。
3. 1度の作業時間が長すぎる（例: 4時間）タスクは、2時間×2枠のように適宜分割して `events` に配置して構いません。
   - その場合、各枠の `taskId` は元のタスクIDとし、`id` を一意にしてください。
4. カレンダーに配置しきれなかったタスク、または15分程度の「小さな砂」は無理に配置せず、YAMLの `goals` リストの中で `status: pool` にしておくこと（勇気を持って見送る）。
5. 一部だけ配置したタスクは `status: partial` にすること。
6. YAMLの行頭 `insight:` に、なぜそのタスクを見送ったのか、どういう戦略で石を配置したのかを1〜2段落で語ること。
7. eventsリストは必ず start(開始日時)の昇順に並び替えること。
```

## 6. 今後の改善フェーズ（Next Steps）
このファイルを受け取ったAIは、上記の設計思想を完全に理解した上で、今後の機能拡張やコードのリファクタリング、プロンプトの改善をサポートすること。